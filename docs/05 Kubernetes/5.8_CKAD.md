# Certified Kubernetes Application Developer

### Core commands

Pods

```bash
kubectl get pods

kubectl get pods --namepace=test

kubectl run webapp --image=nginx

kubectl run redis --image=redis:alpine --dry-run=client -o=yaml > redis-pod.yaml

kubectl describe pod webapp

kubectl get pods -o wide

kubectl delete pod webapp
```

ReplicaSets

```bash
kubectl get replicaset

kubectl get rs

kubectl describe rs new-replica-set

kubectl edit rs new-replica-set

kubectl replace --force -f /tmp/kubectl-edit.yaml

kubectl scale rs new-replica-set --replicas=5
```

Deployments

```bash
kubectl create deployment nginx --image=nginx --replicas=4

# Используется для получения документации по ресурсу
kubectl explain deployment

# Список всех ресурсов
kubectl api-resources

# Показывает историю изменений для указанного развертывания
kubectl rollout history deployment/my-app

# Используется для просмотра статуса процесса развертывания
kubectl rollout status deployment/my-app

# Откатывает развертывание к предыдущему состоянию
kubectl rollout undo deployment/my-app

# Откатывает развертывание к 3 состоянию
kubectl rollout undo deployment/my-app --to-revision=3

# Сохранить в файл
kubectl get deploy/my-deployment -o yaml > my-deploy.yaml

# Set a deployment's nginx container image to nginx:1.9.1
kubectl set image deployment/nginx nginx=nginx:1.9.1

# Update image of all containers of daemonset abc to nginx:1.9.1
kubectl set image daemonset abc *=nginx:1.9.1
```

Service

```bash
kubectl get svc

kubectl expose pod redis --port=6379 --name redis-service
```

### Service

Формат доменного имени для обращения к такому сервису изнутри кластера Kubernetes следующий:

```bash
<service-name>.<namespace>.svc.cluster.local
```

```yaml
---
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: NodePort
  selector:
    app.kubernetes.io/name: MyApp
  ports:
    - port: 80
      targetPort: 80
      # will allocate a port from a range (default: 30000-32767)
      nodePort: 30007
```

Headless сервисы в Kubernetes — это специальный тип сервиса, который не получает кластерный IP-адрес.

Формат DNS-записи для каждого пода будет 
```bash
<pod-name>.<headless-service-name>.<namespace>.svc.cluster.local
```

```yaml
---
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  clusterIP: None
  selector:
    app: my-app
  ports:
  - protocol: TCP
    port:  80
    targetPort:  9376
```

### ConfigMap

```bash
kubectl create configmap  webapp-config-map --from-literal=APP_COLOR=darkblue
```

```yaml
---
apiVersion: v1
kind: ConfigMap
data:
  testkey: hello
  testkey2: hello2

---
  containers:
    - name: test-container
      image: registry.k8s.io/busybox
      command: [ "/bin/sh", "-c", "env" ]
      envFrom:
      - configMapRef:
          name: special-config

---
  containers:
    - name: test-container
      image: registry.k8s.io/busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how

---
  containers:
  - name: mypod
    image: nginx
    volumeMounts:
    - name: config-volume
      mountPath: /etc/config
  volumes:
  - name: config-volume
    configMap:
      name: my-configmap
```

### Secret

```bash
kubectl create secret generic db-secret --from-literal=DB_Host=sql01 --from-literal=DB_User=root
```

```yaml
---
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm

---
apiVersion: v1
kind: Pod
metadata:
  name: envfrom-secret
spec:
  containers:
  - name: envars-test-container
    image: nginx
    envFrom:
    - secretRef:
        name: test-secret

---
  containers:
  - name: envars-test-container
    image: nginx
    env:
    - name: BACKEND_USERNAME
      valueFrom:
        secretKeyRef:
          name: backend-user
          key: backend-username

---
  containers:
  - name: mypod
    image: myimage
    volumeMounts:
    - name: mysecret
      mountPath: "/etc/mysecret"
      readOnly: true
  volumes:
  - name: mysecret
    secret:
      secretName: mysecret
```

### Persistent Volume

```yaml
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-log
spec:
  persistentVolumeReclaimPolicy: Retain
  accessModes:
    - ReadWriteMany
  capacity:
    storage: 100Mi
  hostPath:
    path: /pv/log

---
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: claim-log-1
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 50Mi

---
apiVersion: v1
kind: Pod
metadata:
  name: webapp
spec:
  containers:
  - name: event-simulator
    image: kodekloud/event-simulator
    env:
    - name: LOG_HANDLERS
      value: file
    volumeMounts:
    - mountPath: /log
      name: log-volume

  volumes:
  - name: log-volume
    persistentVolumeClaim:
      claimName: claim-log-1
```

### Network Policies

```yaml
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-network-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      role: db
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - ipBlock:
        cidr: 172.17.0.0/16
        except:
        - 172.17.1.0/24
    - namespaceSelector:
        matchLabels:
          project: myproject
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
      port: 6379
  egress:
  - to:
    - ipBlock:
        cidr: 10.0.0.0/24
    - namespaceSelector:
        matchExpressions:
        - key: namespace
          operator: In
          values: ["frontend", "backend"]
```

### Node Affinity

```bash
kubectl label node node01 color=blue
```

```yaml
---
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: topology.kubernetes.io/zone
            operator: In
            values:
            - antarctica-east1
            - antarctica-west1
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 1
        preference:
          matchExpressions:
          - key: another-node-label-key
            operator: In
            values:
            - another-node-label-value
```

### Pod Anti Affinity

```yaml
apiVersion: v1
kind: Pod
metadata:
 name: my-pod
 labels:
    app: myapp
spec:
 affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: app
            operator: In
            values:
            - myapp
        topologyKey: "kubernetes.io/hostname"
 containers:
 - name: my-container
    image: myapp-image
```

### Pod Distruption Budgets

```yaml
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
 name: nginx-pdb
spec:
 minAvailable: 1
 selector:
   matchLabels:
     app: nginx
```

### Taints and Toleration

Taints это запрет, разграничивающий доступ так что попасть туда можно только по приглашениям.
Tolerations – это как раз приглашение для входа.

```bash
kubectl taint nodes node01 spray=mortein:NoSchedule
```

```yaml
---
apiVersion: v1
kind: Pod
metadata:
  name: bee
spec:
  containers:
  - image: nginx
    name: bee
  tolerations:
  - key: spray
    value: mortein
    effect: NoSchedule
    operator: Equal
```

### ServiceAccount, Role, Binding

```bash
kubectl create sa dashboard-sa

kubectl create token dashboard-sa

kubectl set serviceaccount deploy/web-dashboard dashboard-sa
```

```bash
kubectl create clusterrole --help

kubectl create clusterrole storage-admin --resource=persistentvolume,storageclasses --verb=list,create,get,watch

kubectl create clusterrolebinding admin --user=admin --clusterrole=storage-admin
```

```yaml
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups:
  - ''
  resourceNames:
  - my-pod
  resources:
  - pods
  verbs:
  - get
  - watch
  - list

---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: read-pods
  namespace: default
subjects:
- kind: ServiceAccount
  name: dashboard-sa # Name is case sensitive
  namespace: default
roleRef:
  kind: Role #this must be Role or ClusterRole
  name: pod-reader # this must match the name of the Role or ClusterRole you wish to bind to
  apiGroup: rbac.authorization.k8s.io
```
